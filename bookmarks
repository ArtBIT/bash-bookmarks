#!/bin/env bash
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"

# This is a bash script that allows you to manage your bookmarks from the command line.
# It is meant to be used as a standalone script, but you can also source it from your .bashrc or .zshrc
# and use it as a library.
#
# Dependencies:
#   fzf             For fuzzy finding. Install it with your package manager or from https://github.com/junegunn/fzf
#   glow            For displaying markdown files. Install it with your package manager or from https://github.com/charmbracelet/glow
#   fdfind          For finding files. Install it with your package manager or from https://github.com/sharkdp/fd
#   curl            For checking if a URL is working / fetching the title of a URL
#
# General unix tools:
#   xargs           For passing arguments to glow
#   iconv           For removing accents from strings
#   sed             For slugifying strings
#   grep            For filtering files by content
#

# Configuration
# -------------
# You can override these variables in your .bashrc or .zshrc
# Specify the editor you want to use to edit your bookmarks
MARKDOWN_EDITOR=${EDITOR:-"vim"}
# Specify the viewer you want to use to view your bookmarks
MARKDOWN_VIEWER=${MARKDOWN_VIEWER:-"glow"}
# Specify the directory where your bookmarks are stored
BOOKMARKS_DIR=${BOOKMARKS_DIR:-"$HOME/Documents/bookmarks/data"}
# http://www.ietf.org/rfc/rfc2068.txt
BOOKMARKS_USER_AGENT="Bash-Bookmarks/1.0 (X11; Linux x86_64; rv:10.0)"

# We want to be able to exit the script with Ctrl+C without leaving the terminal in a weird state
# So we trap the EXIT signal and reset the terminal, only if the script is not sourced and the exit code is not 0
if [ "$0" = "$BASH_SOURCE" ]; then
    trap '[[ "$?" -ne 0 ]] && reset' EXIT
fi



bookmarks_usage() {
    echo "Usage: bookmarks [command] [options]"
    echo ""
    echo "Commands:"
    echo "  help            Show this help"
    echo "  add             Add a new bookmark [ options: --title, --uri, --category, --tags, --name ]"
    echo "  edit [query]    Edit a bookmark file"
    echo "  open [query]    Open a bookmark file in the browser"
    echo "  paste           Paste a bookmark from the clipboard"
    echo "  copy            Copy a bookmark into the clipboard"
    echo "  delete [query]  Delete a bookmark file"
    echo ""
    echo "Options:"
    echo "  --title         Title of the bookmark"
    echo "  --uri           URI of the bookmark, can be a URL or a file path"
    echo "  --category      Category of the bookmark"
    echo "  --tags          Tags of the bookmark"
    echo "  --name          Name of the bookmark file"
    echo "  [query]         Query to filter bookmarks, you can filter by title, tags, category, etc."
    echo ""
    echo "Examples:"
    echo "  bookmarks edit"
    echo "  bookmarks edit \"my query\""
    echo "  bookmarks open"
    echo "  bookmarks open \"my query\""
    echo "  bookmarks add --title \"My title\" --uri \"https://example.com\" --category \"My category\" --tags \"tag1,tag2\" --name \"my-bookmark\""
    echo "  bookmarks add --uri ~/Downloads # add a bookmark to a local directory"
    echo "  bookmarks paste # add a bookmark from the clipboard"
}

# Transform the string debug level to integer
log_level_num() {
    local level="$1"
    case "$level" in
        debug)
            echo 7
            ;;
        verbose)
            echo 6
            ;;
        info)
            echo 5
            ;;
        warning)
            echo 3
            ;;
        error)
            echo 2
            ;;
        critical)
            echo 1
            ;;
        *)
            echo 1
            ;;
    esac
}

# Log a message to stderr and to the log file
log() {
    DEBUG=${DEBUG:-"info"}
    local level="$1"
    shift
    local level_num=$(log_level_num "$level")
    local debug_level_num=$(log_level_num "$DEBUG")

    if [ "$level_num" -gt "$debug_level_num" ]; then
        return 0
    fi

    echo "[$level] $@" >&2
    echo "[$(date +"%Y-%m-%d %H:%M:%S")] $@" >> $SCRIPT_DIR/bookmarks.log
}

# Log a message to stderr and to the log file and exit with error
die() {
    log critical "$@" >&2
    exit 1
}

# Decode URL encoded string
urldecode() {
    echo "$1" | sed -e 's/+/ /g' -e 's/%\([0-9A-F][0-9A-F]\)/\\\\\\x\1/g' | xargs echo -e

}

# Get the OS name
get_os() {
    local os=$(uname -s)
    case "$os" in
        Linux)
            echo "linux"
            ;;
        Darwin)
            echo "mac"
            ;;
        CYGWIN*|MINGW32*|MSYS*|MINGW*)
            echo "windows"
            ;;
        *)
            echo "unknown"
            ;;
    esac
}

get_uri_from_file() {
    local file="$1"
    [ -z "$file" ] && die "No file provided"

    local uri=$(cat "$file" | grep "^uri:" | sed -e "s/^uri: //")
    echo "$uri"
}

get_clipboard() {
    local os=$(get_os)
    case "$os" in
        linux)
            xclip -selection clipboard -o
            ;;
        mac)
            pbpaste
            ;;
        windows)
            powershell.exe -command "Get-Clipboard"
            ;;
        *)
            die "Unsupported OS"
            ;;
    esac
}

set_clipboard() {
    local os=$(get_os)
    case "$os" in
        linux)
            echo "$1" | xclip -selection clipboard
            ;;
        mac)
            echo "$1" | pbcopy
            ;;
        windows)
            powershell.exe -command "Set-Clipboard -Value $1"
            ;;
        *)
            die "Unsupported OS"
            ;;
    esac
}

get_title_from_uri() {
    local uri="$1"
    [ -z "$uri" ] && die "No URI provided"

    if is_url "$uri"; then
        curl -s --user-agent "$BOOKMARKS_USER_AGENT" "$uri" | grep -oP '(?<=<title>).*?(?=</title>)'
    elif is_file "$uri"; then
        # if file is pdf or a document try to get the title from the metadata
        local extension=$(echo "$uri" | grep -oP '\.[a-zA-Z0-9]+$')
        if [ "$extension" == ".pdf" ]; then
            pdftk "$uri" dump_data | grep -oP '(?<=InfoValue: ).*?(?=\\n)'
        elif [ "$extension" == ".doc" ] || [ "$extension" == ".docx" ]; then
            catdoc "$uri" | grep -oP '(?<=Title:).*?(?=\\n)'
        else
            basename "$uri"
        fi
    else
        die "Invalid URI"
    fi
}

# Transform a string to a slug
# Example: "My title - Söme äccents" -> "my-title-some-accents"
slugify() {
    result="$@"

    # remove accents
    result=$(echo "$result" | iconv -f utf8 -t ascii//TRANSLIT)

    # slugify a string
    result=$(echo "$result" | tr '[:upper:]' '[:lower:]' | sed -e 's/[^[:alnum:]]/-/g' -e 's/^-+\|-+$//g' -e 's/-\+/-/g')

    echo $result;
}

display_markdown() {
    [ -z "$1" ] && die "No file provided"
    echo "$1" | xargs $MARKDOWN_VIEWER
}

edit_markdown() {
    [ -z "$1" ] && die "No file provided"
    log info "Opening $1 in $MARKDOWN_EDITOR..."
    "$MARKDOWN_EDITOR" "$1"
}

open_uri() {
    local uri="$1"
    log info "Opening [$uri]"
    [ -z "$uri" ] && die "No URI provided"
    # check if uri is an URL
    if [[ "$uri" =~ ^https?:// ]]; then
        os_open "$uri"
        return 0
    fi
    if is_file "$uri"; then
        # strip file:// from uri
        local file=$(echo "$uri" | sed -e "s/^file:\/\///")

        # if file is a directory, cd into it
        if [ -d "$file" ]; then
            cd "$file"
        else
            $EDITOR "$file"
        fi
        return 0
    fi
    log error "Unsuported URI: $1"
}

os_open() {
    [ -z "$1" ] && die "No URI provided"

    log info "Opening $1 in browser..."
    local os=$(get_os)
    case "$os" in
        linux)
            xdg-open "$1"
            ;;
        mac)
            open "$1"
            ;;
        *)
            die "Unsuported OS: $os"
            ;;
    esac
}

# Search the bookmarks directory for a file using fzf
fuzzy_file() {
    local files=$(fdfind --type f -e md .)
    # if "$1" is not empty, filter files by whether file contents contains "$1"
    if [ ! -z "$1" ]; then
        files=$(echo "$files" | xargs grep -l "$1")
    fi
    file=$(echo "$files" | fzf)
    [ -z "$file" ] && die "No file selected"

    realpath "$file"
}

is_url() {
    local url="$1"
    [[ "$url" =~ ^https?:// ]]
}

is_file() {
    local uri="$1"
    is_local_file "$uri" || is_file_uri "$uri"
}

is_file_uri() {
    [[ "$1" =~ ^file:// ]]
}

is_local_file() {
    local uri="$1"
    [[ "$uri" =~ ^/ ]] || [[ "$uri" =~ ^~ ]] || [[ "$uri" =~ ^\. ]] || [[ "$uri" =~ ^\.\. ]];
}

is_uri_accessible() {
    local uri="$1"
    if is_url "$uri"; then
        http_status=$(curl -s --user-agent "$BOOKMARKS_USER_AGENT" --head "$uri" | head -n 1 | grep "HTTP/[0-9.]\+ [12345].." | cut -d " " -f 2)
        log debug "HTTP status code: $http_status"
        # check if status code is 2xx or 3xx
        [[ "$http_status" =~ ^[23] ]] && return 0 || return 1
    elif is_file "$uri"; then
        # check if readable
        [ -r "${uri#file://}" ]
        return $?
    fi
    # unknown URI scheme, return false
    return 1
}

# Create a new bookmark
# Options:
#   --title         Title of the bookmark
#   --uri           URI of the bookmark
#   --category      Default: unsorted, the subdirectory of the bookmarks directory where the bookmark will be saved
#   --tags          Comma separated list of tags
#   --name          Name of the bookmark file
#
# Returns the path of the created bookmark
#
# If --title or --uri is not provided, the user will be prompted for them
# If --name is not provided, it will default to a slugified version of the title
create_bookmark() {
    local category=""
    while true; do
        case "$1" in
            --title)
                shift
                local title=$(urldecode "$1")
                shift
                ;;
            --uri)
                shift
                local uri=$(urldecode "$1")
                if is_file "$uri"; then
                    # expand dot character
                    # if uri equals  to dot
                    if [[ "$uri" = "." ]]; then
                        uri="$OLDPWD"
                    elif [[ "$uri" = ".." ]]; then
                        uri="$OLDPWD/.."
                    # expand ~ character
                    elif [[ "$uri" =~ ^~ ]]; then
                        uri="${uri/#\~/$HOME}"
                    # expand relative paths
                    elif [[ "$uri" =~ ^\./ ]]; then
                        uri="${uri/#./$OLDPWD}"
                    elif [[ "$uri" =~ ^\.\./ ]]; then
                        uri="${uri/#../$OLDPWD/..}"
                    fi
                    uri=$(realpath "${uri#file://}")
                fi
                shift
                ;;
            --category)
                shift
                category=$(urldecode "$1")
                shift
                ;;
            --tags)
                shift
                local tags=$(urldecode "$1")
                shift
                ;;
            --name)
                shift
                local name=$(urldecode "$1")
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    # If uri is not working skip it
    if ! is_uri_accessible "$uri"; then
        die "URI is not accessible: $uri"
    fi

    if [ -z "$category" ]; then
        if is_local_file "$uri"; then
            category="files"
        else
            category="unsorted"
        fi
    fi

    # If title is empty, try to get it from URI
    if [ -z "$title" ]; then
        title=$(get_title_from_uri "$uri")
    fi

    # If title is still empty infer it from the last part of the URI
    if [ -z "$title" ]; then
        title=$(echo "$uri" | grep -oP '(?<=/)[^/]*$')
    fi
    if [ -z "$name" ]; then
        local name="$title"
    fi

    log info "Creating bookmark:"
    log info "  Title: $title"
    log info "  URI: $uri"
    log info "  Category: $category"
    log info "  Tags: $tags"
    log info "  Name: $name"

    [ -z "$title" ]    && die "Title cannot be empty for $uri"
    [ -z "$uri" ]      && die "URI cannot be empty for $title"
    [ -z "$category" ] && die "Category cannot be empty for $title"

    mkdir -p "$category"
    local filename="$category/$(slugify "$name").md"
    if [ -f "$filename" ]; then
        die "File already exists: $filename, skipping"
    fi


    # Write template to file
    cat > "$filename" <<EOF
---
title: $title
uri: $uri
tags: [$tags]
---
[$uri]($uri)
EOF
    
    echo "$BOOKMARKS_DIR/$filename"
}


# Main bookmarks function
# Usage: bookmarks <command> [args]
# Commands:
#   add         Add a new bookmark
#   paste       Paste a new bookmark from the clipboard
#   copy        Copy a new bookmark into the clipboard
#   edit        Edit a bookmark
#   open        Open a bookmark
#   delete      Delete a bookmark

bookmarks() {
    OLDPWD="$PWD"
    pushd "$BOOKMARKS_DIR" &>/dev/null
    local result=0

    case "$1" in
        copy)
            shift
            local filename=$(fuzzy_file "$1")
            [ -z "$filename" ] && die "No file found for tag: $1"

            local uri=$(get_uri_from_file "$filename")
            if [ -z "$uri" ]; then
                die "No URI found for file: $filename"
            fi
            log info "Copying bookmark to clipboard..."
            set_clipboard "$uri"
            result=$?
            ;;

        paste)
            shift
            local uri=$(get_clipboard)
            if [ -z "$uri" ]; then
                die "Clipboard is empty"
            fi
            log info "Adding bookmark from clipboard..."
            create_bookmark --uri "$uri" "$@"
            result=$?
            ;;

        add)
            shift

            # if there is only one argument and it is a valid URI, use it as the URI
            if [ "$#" -eq 1 ] && is_uri_accessible "$1"; then
                log info "Adding quick bookmark..."
                create_bookmark --uri "$1"
                result=$?
            else
                log info "Adding bookmark..."
                create_bookmark "$@"
                result=$?
            fi
            ;;

        edit)
            shift
            local filename=$(fuzzy_file "$1")
            [ -z "$filename" ] && die "No file found for tag: $1"

            edit_markdown "$filename"
            result=$?
            ;;

        open)
            shift
            local file=$(fuzzy_file "$1")
            [ -z "$file" ] && die "No file found for tag: $1"

            local uri=$(grep -oP '(?<=uri: ).*' "$file")
            open_uri "$uri"
            result=$?
            ;;

        delete)
            shift
            local file=$(fuzzy_file "$1")
            [ -z "$file" ] && die "No file found for tag: $1"

            log info "Deleting bookmark: $file"
            # confirm before deleting
            if ! confirm "Are you sure you want to delete $file?"; then
                log info "Aborting"
            else
                # delete file
                rm "$file"
                result=$?
            fi
            ;;

        help)
            shift
            bookmarks_usage
            result=$?
            ;;

        *)
            local file=$(fuzzy_file "$1")
            log info "Opening bookmark: $file"
            [ -z "$file" ] && die "No file found for tag: $1"
            [ ! -f "$file" ] && die "File not found: $file"
            uri=$(cat "$file" | grep ^uri | cut -d ' ' -f 2)
            [ -z "$uri" ] && die "No URI found for file: $file"
            # if the URI is a directory we want to cd into it
            popd &>/dev/null
            open_uri "$uri"
            return $?
            ;;
    esac

    popd &>/dev/null
    return $result
}

# if not sourced, run main
if [ "$0" = "$BASH_SOURCE" ]; then
    log debug "Running main: $@"
    bookmarks_result=$(bookmarks "$@")
fi

